algorithm_2

class IObject {
	List<Point> intersection_points	// Точки пересечения с другими объектами
	List<Point> special_point
}

enum VisitState {
	unvisited,
	visited,
	excluded
}

class Pixel {
	VisitState state
}

class ImageWithVisitedMarks {
	bool has_unvisited_pixels()
	Pixel find_first_unvisited_pixel()
	List<Pixel> get_neighbours( Pixel central )	// Все кроме VisitState.excluded
	void convert_all_excluded_to_unvisited()
	Pixel find_vertical_or_horizontal_neghbour( Pixel central, List<Pixel> neigbours )
	bool is_aligned( Pixel a, Pixel b, Pixel c )
}

class VectorizationState {
	Pixel current
	Pixel previous
	Pixel start	// Начальная точка фигуры (отрезка) 
	List<Pixel> neigbours
	List<Pixel> next	// neigbours, кроме previous и VisitState.visited
}

add_object( ref List<IObject> objects, Line line ) {
	
}

function vectorization {

	List<IObject> objects
	iwvm = new ImageWithVisitedMarks( image )
	vs = nullptr
	List<Point> special_points

	while ( iwvm.has_unvisited_pixels() ) {
		if ( vs == null ) {
			Pixel p = iwvm.find_first_unvisited_pixel()
			if ( p == null ) {
				break
			} else {
				vs = new VectorizationState()
				vs.current = p
			}
		}
		
		vs.neigbours = iwvm.get_neighbours( vs.current )
		neighbours_count = vs.neigbours.count

		switch ( neighbours_count ) {
			case 0:
				break

			case 1:
				special_points.add( vs.current )
				vs.current.state = VisitState.visited

				if ( vs.previous == null ) {
					vs.start = vs.current
					vs.previous = vs.current
					vs.current = vs.next[0]
				} else {
					add_object( ref objects, Line( vs.start, vs.current, special_points))

					iwvm.convert_all_excluded_to_unvisited()
					special_points.clear()

					vs = null
				}

				break

			case 2:
				if ( vs.previous == null ) {
					Pixel next = vs.next[0]

					int unvisited_neighbours = 0
					for ( i : vs.next ) {
						if( i.state == VisitState.unvisited ) {
							unvisited_neighbours++;
						}
					}
					if( unvisited_neighbours == 1) {
						vs.current.state = VisitState.visited
					}

					if(vs.current.state == VisitState.unvisited) {
						for ( i : vs.next ) {
							if( i != next ) {
								i.state = VisitState.excluded
							}
						}
					}

					special_points.add( vs.current )

					vs.start = vs.current
					vs.previous = vs.current
					vs.current = next
				} else {
					vs.current.state = VisitState.visited

					if(!ImageWithVisitedMarks.is_aligned(vs.previous, vs.current, vs.next[0])) {
						add_object( ref objects, Line( vs.start, vs.current, special_points))

						iwvm.convert_all_excluded_to_unvisited()
						special_points.clear()

						special_points.add(vs.current)

						vs.start = vs.current
					}

					vs.previous = vs.current
					vs.current = vs.next[0]
				}

				break

			case 3:
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
				if(vs.previous == null) {
					Pixel next = vs.next[0]

					int unvisited_neighbours = 0
					for(i:vs.neighbours()) {	//TODO: neighbours or next
						if( i.state == VisitState.unvisited ) {
							unvisited_neighbours++;
						}
					}
					if( unvisited_neighbours == 1) {
						vs.current.state = VisitState.visited
					}

					if(vs.current.state == VisitState.unvisited) {
						for ( i : vs.next ) {
							if( i != next ) {
								i.state = VisitState.excluded
							}
						}
					}

					special_points.add( vs.current )

					vs.start = vs.current
					vs.previous = vs.current
					vs.current = next
				} else {
					int unvisited_neighbours = 0
					for(i:vs.neighbours()) {	//TODO: neighbours or next
						if(i.state == VisitState.unvisited) {
							unvisited_neighbours++
						}
					}
					if(unvisited_neighbours == 1) {
						vs.current.state = VisitState.visited
					}

					Pixel next = null
					for(i:vs.next) {
						if(ImageWithVisitedMarks.is_aligned(vs.previous, vs.current, i)){
							next = i
							break
						}
					}

					special_points.add(vs.current)
					if(next == null) {
						next = vs.next[0]

						add_object(Line(vs.start, vs.current, special_points))
						iwvm.convert_all_excluded_to_unvisited()
						special_points.clear()
			
						special_points.add(vs.current)

						vs.start = vs.current
					}

					for(i:vs.next) {
						if(i != next) {
							i.state = VisitState.excluded
						}
					}

					vs.previous = vs.current
					vs.current = next
				}

				break

			default:
				break
		}
	}

	return objects
}